# 协议框架设计说明

## 一、为什么要做这个？

### 1.1 现在的痛点

看看现在的 `PC_xieyi_Ctrl.c`，有 **735行** 代码，像这样：

```c
void PC_xieyijiexi(uint8_t zufuchua[], uint16_t lenth) {
    // ... 一堆变量

    if (zufuchua[pHead + 1] == 0xAA) {
        // 开始测试指令，100多行处理代码...
    }
    else if (zufuchua[pHead + 1] == 0xAC) {
        // 查询结果指令，又是一堆代码...
    }
    else if (zufuchua[pHead + 1] == 0xAE) {
        // 设置配置指令...
    }
    else if (zufuchua[pHead + 1] == 0xBA) {
        // 升级指令...
    }
    // 以后还要加更多...
}
```

**问题：**
- 代码越来越长，难以维护
- 加新协议要改这个大文件，容易出错
- 想支持其他设备（气表、热表）要复制粘贴大量代码
- 上位机如果换了（比如换个MES系统），又要大改

### 1.2 我们想要什么

```
现在：所有协议代码混在一起
      ↓
目标：每种协议独立一个文件，像插件一样随意组合
```

---

## 二、整体架构

### 2.1 系统结构图

```
┌────────────────────────────────────────────────────────────────┐
│                         测试工装主程序                          │
│                            main.c                              │
└───────────────────────────┬────────────────────────────────────┘
                            │
                            │ 调用
                            ▼
┌────────────────────────────────────────────────────────────────┐
│                        协议管理器                               │
│                   protocol_manager.c                           │
│  ┌──────────────────────┐    ┌──────────────────────┐         │
│  │ 上位机协议列表        │    │ 下位机协议列表        │         │
│  │ ├─ MES协议 ✓(当前)   │    │ ├─ 水表协议 ✓(当前)  │         │
│  │ ├─ 协议B (备用)      │    │ ├─ 气表协议 (备用)   │         │
│  │ └─ 协议C (备用)      │    │ └─ 热表协议 (备用)   │         │
│  └──────────────────────┘    └──────────────────────┘         │
└───────────────────────────┬────────────────────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              │                           │
              ▼                           ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│      PC/ 目录            │   │     Device/ 目录        │
│   (上位机协议实现)        │   │    (下位机协议实现)      │
│                         │   │                         │
│  pc_protocol_mes.c      │   │  device_protocol_       │
│  (MES系统协议)           │   │    water_meter.c       │
│                         │   │  (水表协议)             │
│  以后可以加：            │   │                         │
│  pc_protocol_xxx.c      │   │  以后可以加：            │
│  (其他MES系统)           │   │  device_protocol_       │
│                         │   │    gas_meter.c         │
│                         │   │  (气表协议)             │
└─────────────────────────┘   └─────────────────────────┘
```

### 2.2 文件结构

```
Components/Protocol/
│
├── protocol.h              # 【对外接口】只需要包含这一个文件
├── protocol_def.h          # 公共定义（帧头帧尾、错误码等）
├── protocol_manager.h      # 协议管理器接口
├── protocol_manager.c      # 协议管理器实现
│
├── PC/                     # ===== 上位机协议 =====
│   ├── pc_protocol.h       # 上位机协议公共定义
│   ├── pc_protocol_legacy.c    # 【推荐】Legacy适配层，对接现有PC_xieyi_Ctrl.c
│   ├── pc_protocol_upgrade.c   # 【新增】APP升级协议 (0xBA/0xBB)
│   └── pc_protocol_mes.c       # MES系统协议(重新实现版本)
│
└── Device/                 # ===== 下位机协议 =====
    ├── device_protocol.h   # 下位机协议公共定义
    └── device_protocol_water_meter.c  # 水表协议实现
```

---

## 二点五、Legacy适配层说明

### 为什么需要Legacy适配层？

现有的 `PC_xieyi_Ctrl.c` 有 **735行** 代码，运行稳定。我们不想直接修改它，而是通过适配层来接入Protocol框架：

```
┌─────────────────────────────────────────┐
│         Protocol 框架                    │
│                                         │
│  Protocol_PC_Parse(data, len)           │
│         │                               │
│         ▼                               │
│  ┌─────────────────────────┐            │
│  │  legacy_pc_protocol     │            │
│  │  (pc_protocol_legacy.c) │            │
│  └───────────┬─────────────┘            │
│              │ 转发                      │
│              ▼                          │
│  ┌─────────────────────────┐            │
│  │  PC_xieyijiexi()        │            │
│  │  (PC_xieyi_Ctrl.c)      │  ← 现有代码不动 │
│  └─────────────────────────┘            │
└─────────────────────────────────────────┘
```

### APP升级协议 (0xBA/0xBB)

新增了独立的升级协议处理模块，支持：
- **手动模式**: 人工配置参数，用于调试
- **自动模式**: 预设参数，快速升级

升级命令格式 (0xBA):
```
68 BA 0D [工位] [模式] [波特率] [协议] [超时] [日志] [固件大小2字节] [校验] 16
```

升级应答格式 (0xBB):
```
68 BB 07 [工位] [状态] [校验] 16
```

---

## 三、核心概念

### 3.1 协议接口（ProtocolInterface）

每个协议都要实现这个"标准接口"，就像USB接口一样，不管什么设备，插上就能用：

```c
typedef struct {
    const char *name;           // 协议名字，用于识别，比如 "water_meter"

    bool (*init)(void);         // 初始化函数

    ProtocolResult (*parse)     // 【核心】解析收到的数据
        (uint8_t *data, uint16_t len);

    bool (*send_cmd)            // 【核心】发送命令
        (uint16_t cmd, void *param);

    void (*on_response)         // 收到响应时的回调
        (uint16_t code, const uint8_t *data, uint16_t len);

    void (*set_send_func)       // 设置硬件发送函数
        (ProtocolSendFunc send_func);

} ProtocolInterface;
```

**为什么这样设计？**

- 每个协议只需要关心自己的事情（解析自己的数据格式）
- 协议管理器不需要知道具体协议细节，只要调用这些标准函数就行
- 加新协议只需要实现这几个函数，不用改其他代码

### 3.2 协议管理器（Protocol Manager）

协议管理器就像一个"调度中心"：

```
         收到数据
            │
            ▼
    ┌───────────────┐
    │  协议管理器    │
    │               │
    │ "当前用的是   │
    │  哪个协议？"  │
    │               │
    │  查表 → 找到  │
    │  MES协议      │
    └───────┬───────┘
            │
            ▼
    调用 MES协议的 parse() 函数
```

主要功能：
1. **注册协议**：把协议加到列表里
2. **切换协议**：运行时可以换用不同协议
3. **分发数据**：收到数据后，交给当前协议处理

---

## 四、使用方法

### 4.1 初始化（在 main.c 里做一次）

```c
#include "Protocol/protocol.h"

int main(void) {
    // ... 其他初始化 ...

    // 【推荐方式】使用Legacy适配层，兼容现有PC_xieyi_Ctrl.c代码
    Protocol_InitWithLegacy();

    // 【方式2】完整使用新框架
    // Protocol_InitWithDefaults();

    // 【方式3】手动初始化（如果需要自定义）
    // Protocol_Init();
    // Protocol_RegisterPC(&legacy_pc_protocol);       // Legacy适配层
    // Protocol_RegisterPC(&upgrade_pc_protocol);      // 升级协议
    // Protocol_RegisterDevice(&water_meter_protocol); // 水表协议
    // Protocol_SetActivePC("legacy");                 // 设置活跃协议

    // 设置发送函数（告诉协议层怎么发数据）
    Protocol_SetPCSendFunc(uart0_send);       // PC串口用 uart0
    Protocol_SetDeviceSendFunc(uart1_send);   // 水表串口用 uart1

    // ... 主循环 ...
}
```

### 4.2 处理接收数据

```c
// 在 uart0 中断里（收到MES系统数据）
void UART0_RX_Handler(void) {
    uint8_t data[256];
    uint16_t len = uart0_read(data, sizeof(data));

    // 直接丢给协议管理器处理
    // 如果使用Legacy适配层，会自动调用 PC_xieyijiexi()
    Protocol_PC_Parse(data, len);
}

// 在 uart1 中断里（收到水表数据）
void UART1_RX_Handler(void) {
    uint8_t data[256];
    uint16_t len = uart1_read(data, sizeof(data));

    // 直接丢给协议管理器处理
    Protocol_Device_Parse(data, len);
}
```

### 4.3 发送命令

```c
// 发送命令给水表
Protocol_Device_SendCmd(0x2031, NULL);  // 读取表号

// 发送响应给MES
Protocol_PC_SendCmd(PC_CMD_RESULT_RESPONSE, NULL);  // 返回测试结果
```

### 4.4 切换协议（高级用法）

```c
// 假设以后支持了气表，可以这样切换：
Protocol_SetActiveDevice("gas_meter");

// 切换回水表：
Protocol_SetActiveDevice("water_meter");

// 查看当前用的什么协议：
Protocol_PrintInfo();
```

---

## 五、添加新协议

### 5.1 添加新的下位机协议（比如气表）

**第1步：创建文件**

复制 `device_protocol_water_meter.c`，改名为 `device_protocol_gas_meter.c`

**第2步：修改协议名称和实现**

```c
// device_protocol_gas_meter.c

// 修改协议名称
const ProtocolInterface gas_meter_protocol = {
    .name = "gas_meter",        // 改成气表
    .init = gm_init,
    .parse = gm_parse,          // 实现气表的解析逻辑
    .send_cmd = gm_send_cmd,
    // ...
};

// 实现气表特有的解析逻辑
static ProtocolResult gm_parse(uint8_t *data, uint16_t len) {
    // 气表协议的解析代码...
    // 和水表不一样的地方在这里改
}
```

**第3步：声明和注册**

在 `device_protocol.h` 中添加：
```c
extern const ProtocolInterface gas_meter_protocol;
```

在 `protocol.h` 的 `Protocol_RegisterDefaults()` 中添加：
```c
Protocol_RegisterDevice(&gas_meter_protocol);
```

**完成！** 不需要改其他任何文件。

### 5.2 添加新的上位机协议（比如另一个MES系统）

同样的步骤，在 `PC/` 目录下操作即可。

---

## 六、数据流程图

### 6.1 接收数据流程

```
MES系统发送数据
      │
      ▼
┌─────────────┐
│   UART0     │
│  接收中断   │
└──────┬──────┘
       │ 收到 [68 AA 19 01 ... 16]
       ▼
┌─────────────────────────────────┐
│  Protocol_PC_Parse(data, len)   │
│         协议管理器               │
└──────┬──────────────────────┘
       │ 查找当前活跃的上位机协议
       │ 找到 "mes" (MES协议)
       ▼
┌─────────────────────────────────┐
│  mes_parse(data, len)            │
│  MES协议的解析函数               │
│                                 │
│  1. 找帧头 0x68                  │
│  2. 读取命令码 0xAA (开始测试)   │
│  3. 验证校验和                   │
│  4. 解析参数                     │
│  5. 调用 test_start()           │
│  6. 发送应答                     │
└─────────────────────────────────┘
```

### 6.2 发送数据流程

```
要发送测试结果
      │
      ▼
┌─────────────────────────────────────┐
│  Protocol_PC_SendCmd(0xAD, NULL)    │
│           协议管理器                 │
└──────┬──────────────────────────────┘
       │ 查找当前活跃的上位机协议
       ▼
┌─────────────────────────────────────┐
│  mes_send_cmd(0xAD, NULL)            │
│  MES协议的发送函数                   │
│                                     │
│  1. 组装帧 [68 AD len data... cs 16]│
│  2. 计算校验和                       │
│  3. 调用 s_send_func() 发送         │
└──────┬──────────────────────────────┘
       │
       ▼
┌─────────────┐
│   UART0     │
│   发送      │
└─────────────┘
       │
       ▼
   MES系统收到数据
```

---

## 七、与现有代码的关系

### 7.1 现有代码不用改

原来的 `PC_xieyi_Ctrl.c` 和 `tongxin_xieyi_Ctrl.c` 还可以继续用！

新框架是**增量添加**的，你可以：
- 继续用原来的代码
- 逐步迁移到新框架
- 新功能用新框架，旧功能保持不变

### 7.2 迁移路径

```
阶段1：现状
├── PC_xieyi_Ctrl.c (继续用)
├── tongxin_xieyi_Ctrl.c (继续用)
└── Components/Protocol/ (新框架，备用)

阶段2：逐步迁移
├── PC_xieyi_Ctrl.c (部分功能迁移到新框架)
├── tongxin_xieyi_Ctrl.c (部分功能迁移到新框架)
└── Components/Protocol/
    ├── PC/pc_protocol_mes.c (新)
    └── Device/device_protocol_water_meter.c (新)

阶段3：完全迁移（可选）
├── PC_xieyi_Ctrl.c (删除或保留兼容)
├── tongxin_xieyi_Ctrl.c (删除或保留兼容)
└── Components/Protocol/ (主要代码)
```

---

## 八、常见问题

### Q1: 我只是想加个新命令，需要用这个框架吗？

**不需要。** 在原来的 `PC_xieyi_Ctrl.c` 里加个 `else if` 就行。

这个框架是为了：
- 支持多种设备（水表、气表、热表）
- 支持不同的MES系统
- 让代码更好维护

### Q2: 框架会增加多少代码量？

```
protocol_manager.c  约 300 行
protocol_def.h      约 130 行
pc_protocol.h       约 120 行
device_protocol.h   约 120 行
------------------------
框架本身约 670 行
```

但每个具体协议实现会更清晰、更独立。

### Q3: 会影响性能吗？

基本不会。多了一层函数调用，在嵌入式上影响可以忽略（微秒级）。

### Q4: 可以不用这个框架吗？

**完全可以！** 这只是一个可选的组件。
- 不想用：直接不 include，不影响任何现有代码
- 想用：逐步迁移，按自己节奏来

---

## 九、总结

| 项目 | 说明 |
|------|------|
| **目的** | 让协议代码模块化，方便扩展和维护 |
| **核心思想** | 每种协议独立一个文件，通过统一接口管理 |
| **使用难度** | 简单，3个API就能用起来 |
| **对现有代码影响** | 无，完全增量添加 |
| **适合场景** | 需要支持多种设备或多种上位机系统时 |

**最简单的用法：**

```c
// 初始化
Protocol_InitWithDefaults();

// 收到数据就调用
Protocol_PC_Parse(data, len);      // MES数据
Protocol_Device_Parse(data, len);  // 水表数据

// 完事！
```
